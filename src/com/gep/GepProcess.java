package com.gep;

import java.util.*;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : @gep
//  @ File Name : GepProcess.java
//  @ Date : 2013/4/5
//  @ Author : @shenzhan

/**
 * gep的主要过程
 **/
public class GepProcess {
	/**
	 * 
	 */

	public Population Pop; // 种群
	public FunctionSet Fun; // 函数集
	public List<String> Feature;

	/**
	 * 适应值函数
	 */
	public String FitnessFunType;

	public int MaxGeneration; //
	public int PopulationSize;
	public int HeadLength;
	public static int GeneCount;
	public static int GeneLength;
	public int ChromosomeLength;
	public double MutationRate;
	public double OnePRecomRate;
	public double TwoPRecomRate;
	public double GeneRecomRate;
	public double ISRate;
	public int[] ISElemLength;
	public double RISRate;
	public int[] RISElemLength;
	public double GeneTransRate;
	public double SelectionRange;
	public double Error;
	public double SuccessRate;

	public double TestAccuracy;// 测试准确度
	public double TrainAccuracy;// 训练准确度

	public static int FeatureNum; // 特征数量
	public String[] sFullSet; // 函数集合+特征集合
	public String[] sFeatureSet; // 特征集合

	public double[][] TrainData; // 训练数据
	public double[][] TestData; // 测试数据

	public double[] Fitness;

	public Individual BestIndividual;
	public int BestIndivNum;

	public int[] FeatureSta = null;  //统计数据
	
	int nClassCount;  //多分类中 分类的数目
	int nCurrentClass;  //当前训练区分的 分类号

	/**
	 * 群体初始化
	 **/
	public void InitialPopulation() {
		// 初始化//===========================================================================
		Fitness = new double[this.PopulationSize];
		Fun = new FunctionSet();
		Pop = new Population();
		// ================================================================================
		// 产生必要的字符集合

		// 特征
		sFeatureSet = new String[this.FeatureNum];
		for (int i = 0; i < this.FeatureNum; ++i) {
			sFeatureSet[i] = String.format("%d", i);
		}

		int nTail = this.HeadLength * (Fun.MaxParamCount - 1) + 1; // 尾部长度
		this.GeneLength = this.HeadLength + nTail; // 计算基因长度
		this.ChromosomeLength = GepProcess.GeneCount * GepProcess.GeneLength; // 染色体长度

		String[] sFunSet = new String[Fun.sFunction.size()]; // // 函数集合
		for (int i = 0; i < Fun.sFunction.size(); ++i) {
			sFunSet[i] = Fun.sFunction.get(i);
		}

		sFullSet = new String[sFunSet.length + sFeatureSet.length]; // 函数集合
																	// +特征集合

		int nSetLen = sFunSet.length + sFeatureSet.length;
		for (int i = 0; i < sFunSet.length; ++i) {
			sFullSet[i] = sFunSet[i];
		}
		int m = 0;
		for (int i = sFunSet.length; i < nSetLen; ++i) {
			sFullSet[i] = sFeatureSet[m++];
		}

		Random random = new Random();
		String[] sGene = new String[this.GeneLength];
		for (int i = 0; i < this.PopulationSize; ++i) {

			Individual Indiv = new Individual();// 新个体
			for (int k = 0; k < this.GeneCount; ++k) {

				// 基因头部
				int nIndex;
				int j;
				for (j = 0; j < this.HeadLength; ++j) {
					nIndex = random.nextInt(nSetLen);
					sGene[j] = sFullSet[nIndex];
				}

				// 基因尾部
				for (; j < this.GeneLength; ++j) {
					nIndex = random.nextInt(sFeatureSet.length);
					sGene[j] = sFeatureSet[nIndex];
				}

				Indiv.AddGene(sGene); // 添加基因
			}
			this.Pop.AddIndivdual(Indiv); // 添加个体
		}

	}

	/**
	 * 每一代的评估函数
	 **/
	public void EvalutePopulaton() {

		// 产生适应值计算 对象
		MultClassify FitFun = new MultClassify();               //
		
		//FitnessFunction FitFun=FitnessFunFactory.GetFitnessFun(this.FitnessFunType);
		// 计算适应值
//		if (null == FitFun) {
//			System.out.println("参数 适应度函数不正确");
//			System.exit(1);
//		}
		
	    FitFun.nCurrentClass=this.nCurrentClass;
		FitFun.GetFitness(this.Pop, this.TrainData, this.Fitness);

	}

	
	
	/**
	 * 判断gep是否要结束
	 **/
	public boolean IsTerminate() {

		return false;

	}

	/**
	 * 选择在群体中进行选择
	 **/
	public void Select() {
		Population NewPop = new Population();
		FindBestIndividual();
		NewPop.AddIndivdual(this.BestIndividual); // 精英策略

		double dTotal = 0;
		for (int i = 0; i < this.PopulationSize; ++i) {
			dTotal += this.Fitness[i];
		}

		// 每个个体的概率
		double[] dRate = new double[this.PopulationSize];

		if (dTotal == 0) {
			for (int i = 0; i < this.PopulationSize; ++i) {
				dRate[i] = 1 / (double) this.PopulationSize;
			}
		} else {
			for (int i = 0; i < this.PopulationSize; ++i) {
				dRate[i] = this.Fitness[i] / dTotal;
			}
		}

		// 轮赌盘
		double[] dWheel = new double[this.PopulationSize];
		for (int i = 0; i < this.PopulationSize; ++i) {
			if (0 == i) {
				dWheel[i] = dRate[i];
			} else {
				dWheel[i] = dWheel[i - 1] + dRate[i];
			}
		}

		// 选择
		Random random = new Random();
		for (int i = 1; i < this.PopulationSize; ++i) {
			double d = random.nextDouble();
			int j = 0;
			for (j = 0; j < this.PopulationSize; ++j) {
				if (d < dWheel[j]) {
					break;
				}
			}
			if (j >= this.PopulationSize) {
				j = this.PopulationSize - 1;
			}
			Individual SelectIndiv = (Individual) this.Pop.Get(j).clone(); // 复制个体
			NewPop.AddIndivdual(SelectIndiv); // 加入到新的种群中
		}

		this.Pop = NewPop;

	}

	/**
	 * 查找最优个体
	 */
	public void FindBestIndividual() {
		int nMax = 0;
		double dMaxFitness = this.Fitness[0];
		int i;
		for (i = 1; i < this.Fitness.length; ++i) {
			if (this.Fitness[i] > dMaxFitness) {
				dMaxFitness = this.Fitness[i];
				nMax = i;
			}
		}
		this.BestIndivNum = nMax;
		this.BestIndividual = this.Pop.Get(nMax);
	}

	/**
	 * 变异
	 */
	public void Mutation() {

		Random random = new Random();
		for (int i = 0; i < this.PopulationSize; ++i) {
			for (int j = 0; j < this.ChromosomeLength; ++j) {

				if (random.nextDouble() < this.MutationRate) {
					int nIndex = j % this.GeneLength;
					int k;
					// 基因头部
					if (nIndex < this.HeadLength) {
						k = random.nextInt(this.sFullSet.length);
						Pop.Get(i).Set(j, sFullSet[k]); // 设置变异的基因
					} else { // 尾部
						k = random.nextInt(this.sFeatureSet.length);
						Pop.Get(i).Set(j, sFeatureSet[k]); // 设置变异的基因
					}
				}
			}
		}
	}

	/**
	 * IS 插串
	 */
	public void TransPosIS() {
		Random random = new Random();
		double dRate;
		for (int i = 0; i < this.PopulationSize; ++i) {
			dRate = random.nextDouble();
			if (dRate < this.ISRate) {
				int nIndivNO = random.nextInt(this.PopulationSize); // 随机个体
				Individual Indiv = this.Pop.Get(nIndivNO);

				int nGeneNO = random.nextInt(this.GeneCount); // 随机基因
				int nStart = nGeneNO * this.GeneLength; // 开始位置

				int nSelLen = this.ISElemLength.length;
				int nLength = this.ISElemLength[random.nextInt(nSelLen)]; // 随机长度

				// 随机源位置
				int nSouPos = random.nextInt(this.GeneLength);
				if (nSouPos + nLength > this.GeneLength) {
					nSouPos = this.GeneLength - nLength;
				}
				nSouPos += nStart;

				// 随机目标位置
				int nTarPos;
				do {
					nTarPos = random.nextInt(this.HeadLength);
				} while (0 == nTarPos);
				nTarPos += nStart;

				// 基因IS复制
				List<String> listTemp = Indiv.Chrom.subList(nSouPos, nSouPos
						+ nLength);
				Indiv.Chrom.addAll(nTarPos, listTemp);
				for (int j = 0; j < nLength; ++j) {
					Indiv.Chrom.remove(nStart + this.HeadLength);
				}

			}
		}

	}

	/**
	 * RIS 插串
	 */
	public void TransPosRIS() {
		Random random = new Random();
		double dRate;
		for (int i = 0; i < this.PopulationSize; ++i) {
			dRate = random.nextDouble();
			if (dRate < this.RISRate) {
				int nIndivNO = random.nextInt(this.PopulationSize); // 随机个体
				Individual Indiv = this.Pop.Get(nIndivNO);

				int nGeneNO = random.nextInt(this.GeneCount); // 随机基因
				int nStart = nGeneNO * this.GeneLength; // 开始位置

				int nSelLen = this.RISElemLength.length;
				int nLength = this.RISElemLength[random.nextInt(nSelLen)]; // 随机长度

				// 随机源位置
				int nHeadPos;
				do {
					nHeadPos = random.nextInt(this.HeadLength);
				} while (nHeadPos == 0);
				nHeadPos += nStart;
				while (nHeadPos < (this.HeadLength + nStart)
						&& !Fun.IsFunction(Indiv.Get(nHeadPos))) {
					++nHeadPos;
				}
				if (nHeadPos >= (nStart + this.HeadLength)) { // 找不到函数符号
					continue;
				}
				// 判断长度
				if (this.HeadLength - (nHeadPos - nStart) < nLength) {
					nLength = this.HeadLength - (nHeadPos - nStart);
				}

				// 基因插窜
				List<String> listTemp = Indiv.Chrom.subList(nHeadPos, nHeadPos
						+ nLength);
				Indiv.Chrom.addAll(nStart, listTemp);

				for (int j = 0; j < nLength; ++j) {
					Indiv.Chrom.remove(nStart + this.HeadLength);
				}

			}
		}

	}

	/**
	 * 基因 插串
	 */
	public void TransPosGene() {
		Random random = new Random();
		double dRate;

		// 如果只有一个基因 则跳过这个步骤
		if (this.GeneCount == 1) {
			return;
		}

		for (int i = 0; i < this.PopulationSize; ++i) {
			dRate = random.nextDouble();
			if (dRate < this.GeneTransRate) {

				int nIndivNO = random.nextInt(this.PopulationSize); // 随机个体
				Individual Indiv = this.Pop.Get(nIndivNO);

				int nGeneNO; // 随机基因
				do {
					nGeneNO = random.nextInt(this.GeneCount);
				} while (0 == nGeneNO);

				// 基因插串
				int nStart = nGeneNO * this.GeneLength;
				int nEnd = nStart + this.GeneLength;
				List<String> listTemp = Indiv.Chrom.subList(nStart, nEnd);
				Indiv.Chrom.addAll(0, listTemp); // 把基因插入到开始位置
				// 删除原位置的基因
				for (int j = nStart; j < nEnd; ++j) {
					Indiv.Chrom.remove(nStart + this.GeneLength);
				}

			}
		}

	}

	/**
	 * 单点重组
	 */
	public void RecomOnePoint() {
		int i = 0;
		int nFather;
		int nMother;
		int nPos;
		Random random = new Random();
		double dRate;
		for (i = 0; i < this.PopulationSize; ++i) {

			dRate = random.nextDouble();

			if (dRate < this.OnePRecomRate) {
				// 随机选取两个个体 和 交叉点

				nFather = random.nextInt(this.PopulationSize);// 随机选取交叉个体
				nMother = random.nextInt(this.PopulationSize);
				nPos = random.nextInt(this.ChromosomeLength);

				Individual Father = this.Pop.Get(nFather);
				Individual Mother = this.Pop.Get(nMother);
				String temp;
				// 两个个体交叉重组
				for (int j = 0; j < nPos; ++j) {
					temp = Father.Get(j);
					Father.Set(j, Mother.Get(j));
					Mother.Set(j, temp);
				}

			}
		}
	}

	/**
	 * 两点重组
	 */
	public void RecomTwoPoint() {
		int i = 0;
		int nFather;
		int nMother;
		int nPosPre;
		int nPosLast;
		Random random = new Random();
		double dRate;
		for (i = 0; i < this.PopulationSize; ++i) {
			dRate = random.nextDouble();
			if (dRate < this.TwoPRecomRate) {

				nFather = random.nextInt(this.PopulationSize);// 随机选取交叉个体
				nMother = random.nextInt(this.PopulationSize);
				Individual Father = this.Pop.Get(nFather);
				Individual Mother = this.Pop.Get(nMother);

				nPosPre = random.nextInt(this.ChromosomeLength);
				nPosLast = random.nextInt(this.ChromosomeLength);

				if (nPosPre > nPosLast) {
					int nTemp = nPosLast;
					nPosLast = nPosPre;
					nPosPre = nTemp;
				}

				// 基因交换
				String sTemp;
				for (int j = nPosPre; j < nPosLast; ++j) {
					sTemp = Father.Get(j);
					Father.Set(j, Mother.Get(j));
					Mother.Set(j, sTemp);
				}

			}
		}

	}

	/**
	 * 基因重组
	 */
	public void ReComGene() {
		int i = 0;
		int nFather;
		int nMother;
		Random random = new Random();
		double dRate;

		for (i = 0; i < this.PopulationSize; ++i) {

			dRate = random.nextDouble();

			if (dRate < this.GeneRecomRate) {

				nFather = random.nextInt(this.PopulationSize);// 随机选取交叉个体
				nMother = random.nextInt(this.PopulationSize);
				Individual Father = this.Pop.Get(nFather);
				Individual Mother = this.Pop.Get(nMother);

				int nGeneNo = random.nextInt(this.GeneCount);

				int nStart = nGeneNo * this.GeneLength; // 计算基因的开始 结束位置
				int nEnd = nStart + this.GeneLength;

				// 基因交换
				String sTemp;
				for (int j = nStart; j < nEnd; ++j) {
					sTemp = Father.Get(j);
					Father.Set(j, Mother.Get(j));
					Mother.Set(j, sTemp);
				}
			}
		}

	}

	// +===============================================================================================
	/**
	 * 数据测试
	 * 
	 * @return
	 */
	public double Test() {
		int nRow = this.TestData.length;
		int nCol = this.TestData[0].length;
		
		System.out.println(" row "+nRow+ "  "+nCol);
		System.out.println(this.BestIndividual.Chrom.toString());
		
		int j;
		Expression Exp = new Expression();
		int tp = 0, fp = 0, tn = 0, fn = 0;
		for (j = 0; j < nRow; ++j) {
			double dValue = Exp.GetValue(this.BestIndividual, this.TestData[j]);
			// 二分类 0 类
			if (TestData[j][nCol - 1] == 1) {
				if (dValue < 0) {
					tp++;
				} else {
					fp++;
				}
			} else if (TestData[j][nCol - 1] == 2) {
				if (dValue >= 0) {
					tn++;
				} else {
					fn++;
				}
			}
		}
		this.TestAccuracy = (tp + tn) / (double) nRow;
		return this.TestAccuracy;

	}

	// ====================================================================================================
	// ====================================================================================================
	public double AverageFitness() {
		double dRes = 0;
		for (int i = 0; i < this.PopulationSize; ++i) {
			dRes += this.Pop.Get(i).Fitness;
		}
		dRes = dRes / this.PopulationSize;
		return dRes;
	}

	/**
	 * 统计每个特征出现的个数
	 */
	public void Statictis() {
		if (this.FeatureSta == null) {
			this.FeatureSta = new int[this.FeatureNum];
			for (int n = 0; n < this.FeatureNum; ++n) {
				FeatureSta[n] = 0;
			}
		}
		int i, j;
		Expression Exp = new Expression();
		// 特征频数的统计

		for (i = 0; i < this.PopulationSize; ++i) {

			Individual Indiv = this.Pop.Get(i);

			for (j = 0; j < GepProcess.GeneCount; ++j) {

				List<String> Gene = Indiv.GetGene(j);
				int nLen = Exp.GetValidLength(Gene);

				for (int k = 0; k < nLen; ++k) {
					String str = Gene.get(k);
					int n = Fun.GetParamCount(str);
					if (0 == n) {
						int index = Integer.parseInt(str);
						++FeatureSta[index];
					}
				}

			}

		}
		// for(i=0;i<FeatureSta.length;++i){
		// System.out.print(FeatureSta[i] +"  ");
		// }
	}

	/**
	 * 根据特征的权值进行排序
	 */
	public List<FeatureStru> GetFeatureOrder() {
		int i, j, k;

		// 填充数据
		List<FeatureStru> listFeatStru = new LinkedList<FeatureStru>();
		for (i = 0; i < this.FeatureSta.length; ++i) {
			FeatureStru FeatStru = new FeatureStru();
			FeatStru.nFeatureNO = i;
			FeatStru.nFeatureCount = this.FeatureSta[i];
			listFeatStru.add(FeatStru);
		}

		// 排名 排序
		// 选择排序
		for (i = 0; i < listFeatStru.size() - 1; ++i) {
			k = i;
			FeatureStru Max = listFeatStru.get(i);
			for (j = i + 1; j < listFeatStru.size(); ++j) {
				if (listFeatStru.get(j).nFeatureCount > Max.nFeatureCount) {
					k = j;
					Max = listFeatStru.get(j);
				}
			}
			if (k != i) {
				listFeatStru.set(k, listFeatStru.get(i));
				listFeatStru.set(i, Max);
			}
		}

		for (i = 0; i < listFeatStru.size(); ++i) {
			listFeatStru.get(i).nOrder = i;
		}

		System.out.println();
		 for(i=0;i<listFeatStru.size();++i){
		 FeatureStru Temp=listFeatStru.get(i);
		 String str=String.format("%6d",Temp.nFeatureNO);
		 System.out.print(str);
		 }
		 System.out.println();
//		 for(i=0;i<listFeatStru.size();++i){
//			 FeatureStru Temp=listFeatStru.get(i);
//			 String str=String.format("%6d",Temp.nFeatureCount);
//			 System.out.print(str);
//		}
//		 System.out.println();
//		 for(i=0;i<listFeatStru.size();++i){
//			 FeatureStru Temp=listFeatStru.get(i);
//			 String str=String.format("%6d",Temp.nOrder);
//			 System.out.print(str);
//			 }

		return listFeatStru;
	}

}
